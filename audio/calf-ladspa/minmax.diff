diff -Naur calf-0.0.19kx/src/audio_fx.cpp calf-0.0.19kx.patched/src/audio_fx.cpp
--- calf-0.0.19kx/src/audio_fx.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/audio_fx.cpp	2017-07-05 18:09:21.728705740 -0400
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 #include <time.h>
 #include <math.h>
+#include "minmax.h"
 
 using namespace calf_plugins;
 using namespace dsp;
@@ -643,7 +644,7 @@
     if(_asc and auto_release and asc_c > 0 and _a_att > _att) {
         // check if releasing to average level of peaks is steeper than
         // releasing to 1.f
-        float _delta = std::max((_a_att - _att) / (srate * release), _rdelta / 10);
+        float _delta = MAX((_a_att - _att) / (srate * release), _rdelta / 10);
         if(_delta < _rdelta) {
             asc_active = true;
             _asc_used = true;
@@ -689,7 +690,7 @@
         float _peak;
         
         // calc the attenuation needed to reduce incoming peak
-        float _att = std::min(_limit / peak, 1.f);
+        float _att = MIN(_limit / peak, 1.f);
         // calc release without any asc to keep all relevant peaks
         float _rdelta = get_rdelta(peak, _limit, _att, false);
 
diff -Naur calf-0.0.19kx/src/calf/buffer.h calf-0.0.19kx.patched/src/calf/buffer.h
--- calf-0.0.19kx/src/calf/buffer.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/buffer.h	2017-07-05 18:07:38.696711220 -0400
@@ -21,6 +21,7 @@
 #ifndef __BUFFER_H
 #define __BUFFER_H
 
+#include "minmax.h"
 namespace dsp {
 
 /// decrease by N if >= N (useful for circular buffers)
@@ -131,7 +132,7 @@
     inline int size() { return buf_size; }
     void resize(int new_size, bool fill_with_zeros = false) {
         T *new_buf = new T[new_size];
-        memcpy(new_buf, buf, std::min(buf_size, new_size));
+        memcpy(new_buf, buf, MIN(buf_size, new_size));
         if (fill_with_zeros && buf_size < new_size)
             dsp::zero(new_buf + buf_size, new_size - buf_size);
         if (owns)
diff -Naur calf-0.0.19kx/src/calf/envelope.h calf-0.0.19kx.patched/src/calf/envelope.h
--- calf-0.0.19kx/src/calf/envelope.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/envelope.h	2017-07-05 18:08:09.287709593 -0400
@@ -22,6 +22,7 @@
 #define __CALF_ENVELOPE_H
 
 #include "primitives.h"
+#include "minmax.h"
 
 namespace dsp {
 
@@ -119,7 +120,7 @@
             return;
         // XXXKF what if envelope is already released? (doesn't happen in any current synth, but who knows?)
         // Raise sustain value if it has been changed... I'm not sure if it's needed
-        thiss = std::max(sustain, value);
+        thiss = MAX(sustain, value);
         // Calculate release rate from sustain level
         thisrelease = thiss / release_time;
         // we're in attack or decay, and if decay is faster than release
diff -Naur calf-0.0.19kx/src/calf/fixed_point.h calf-0.0.19kx.patched/src/calf/fixed_point.h
--- calf-0.0.19kx/src/calf/fixed_point.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/fixed_point.h	2017-07-05 18:08:01.555710004 -0400
@@ -20,6 +20,7 @@
  */
 #ifndef __CALF_FIXED_POINT_H
 #define __CALF_FIXED_POINT_H
+#include "minmax.h"
 
 namespace dsp {
 
diff -Naur calf-0.0.19kx/src/calf/giface.h calf-0.0.19kx.patched/src/calf/giface.h
--- calf-0.0.19kx/src/calf/giface.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/giface.h	2017-07-05 18:07:51.071710561 -0400
@@ -27,6 +27,7 @@
 #include <exception>
 #include <string>
 #include <vector>
+#include "minmax.h"
 
 namespace osctl {
     struct osc_client;
@@ -542,7 +543,7 @@
         uint32_t total_out_mask = 0;
         while(offset < end)
         {
-            uint32_t newend = std::min(offset + MAX_SAMPLE_RUN, end);
+            uint32_t newend = MIN(offset + MAX_SAMPLE_RUN, end);
             uint32_t out_mask = process(offset, newend - offset, -1, -1);
             total_out_mask |= out_mask;
             zero_by_mask(out_mask, offset, newend - offset);
diff -Naur calf-0.0.19kx/src/calf/minmax.h calf-0.0.19kx.patched/src/calf/minmax.h
--- calf-0.0.19kx/src/calf/minmax.h	1969-12-31 19:00:00.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/minmax.h	2017-07-05 18:15:43.487685437 -0400
@@ -0,0 +1,8 @@
+/* this stuff was copy/pasted from /usr/include/sys/param.h on Slack 14.2 */
+#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define MAX(a,b) (((a)>(b))?(a):(b))
+#endif
diff -Naur calf-0.0.19kx/src/calf/osc.h calf-0.0.19kx.patched/src/calf/osc.h
--- calf-0.0.19kx/src/calf/osc.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/osc.h	2017-07-05 18:07:29.783711694 -0400
@@ -24,6 +24,7 @@
 
 #include "fft.h"
 #include <map>
+#include "minmax.h"
 
 namespace dsp
 {
@@ -181,7 +182,7 @@
         uint32_t cutoff = SIZE / 2, top = SIZE / 2;
         float vmax = 0;
         for (unsigned int i = 0; i < cutoff; i++)
-            vmax = std::max(vmax, abs(bl.spectrum[i]));
+            vmax = MAX(vmax, abs(bl.spectrum[i]));
         float vthres = vmax / 1024.0;  // -60dB
         float cumul = 0.f;
         while(cutoff > (SIZE / limit)) {
@@ -321,7 +322,7 @@
         table[i] -= dc;
     float thismax = 0;
     for (unsigned int i = 0; i < size; i++)
-        thismax = std::max(thismax, fabsf(table[i]));
+        thismax = MAX(thismax, fabsf(table[i]));
     if (thismax < 0.000001f)
         return;
     double divv = 1.0 / thismax;
diff -Naur calf-0.0.19kx/src/calf/osctl.h calf-0.0.19kx.patched/src/calf/osctl.h
--- calf-0.0.19kx/src/calf/osctl.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/osctl.h	2017-07-05 18:08:30.753708451 -0400
@@ -29,6 +29,7 @@
 #include <netinet/in.h>
 #include <netdb.h>
 #include <iostream>
+#include "minmax.h"
 
 namespace osctl
 {
@@ -378,7 +379,7 @@
     for (uint32_t i = 0; i < len; i += 1024)
     {
         uint8_t tmp[1024];
-        uint32_t part = std::min((uint32_t)1024, len - i);
+        uint32_t part = MIN((uint32_t)1024, len - i);
         s.read(tmp, part);
         buf.write(tmp, part);
     }
@@ -398,7 +399,7 @@
     for (uint32_t i = 0; i < len; i += 1024)
     {
         uint8_t tmp[1024];
-        uint32_t part = std::min((uint32_t)1024, len - i);
+        uint32_t part = MIN((uint32_t)1024, len - i);
         buf.read(tmp, part);
         s.write(tmp, part);
     }
diff -Naur calf-0.0.19kx/src/calf/vumeter.h calf-0.0.19kx.patched/src/calf/vumeter.h
--- calf-0.0.19kx/src/calf/vumeter.h	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/calf/vumeter.h	2017-07-05 18:08:17.582709151 -0400
@@ -22,6 +22,7 @@
 #define __CALF_VUMETER_H
 
 #include <math.h>
+#include "minmax.h"
 
 namespace dsp {
 
@@ -94,7 +95,7 @@
         float tmp = level;
         for (unsigned int i = 0; i < len; i++) {
             float sig = fabs(src[i]);
-            tmp = std::max(tmp, sig);
+            tmp = MAX(tmp, sig);
             if (sig >= 1.f)
                 clip = 1.f;
         }
diff -Naur calf-0.0.19kx/src/ctl_curve.cpp calf-0.0.19kx.patched/src/ctl_curve.cpp
--- calf-0.0.19kx/src/ctl_curve.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/ctl_curve.cpp	2017-07-05 18:06:57.561713407 -0400
@@ -23,6 +23,7 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <math.h>
+#include "minmax.h"
 
 static gpointer parent_class = NULL;
 
@@ -135,7 +136,7 @@
     {
         float x = (*self->points)[i].first, y = (*self->points)[i].second;
         self->log2phys(x, y);
-        float thisdist = std::max(fabs(ex - x), fabs(ey - y));
+        float thisdist = MAX(fabs(ex - x), fabs(ey - y));
         if (thisdist < dist)
         {
             dist = thisdist;
@@ -300,7 +301,7 @@
     hide = false;
     sink->clip(this, pt, x, y, hide);
     
-    float ymin = std::min(y0, y1), ymax = std::max(y0, y1);
+    float ymin = MIN(y0, y1), ymax = MAX(y0, y1);
     float yamp = ymax - ymin;
     if (pt != 0 && pt != (int)(points->size() - 1))
     {
diff -Naur calf-0.0.19kx/src/ctl_vumeter.cpp calf-0.0.19kx.patched/src/ctl_vumeter.cpp
--- calf-0.0.19kx/src/ctl_vumeter.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/ctl_vumeter.cpp	2017-07-05 18:01:33.751730628 -0400
@@ -28,6 +28,7 @@
 #include <gdk/gdk.h>
 #include <sys/time.h>
 #include <string>
+#include "minmax.h"
 
 
 ///////////////////////////////////////// vu meter ///////////////////////////////////////////////
@@ -226,7 +227,7 @@
     long time = tv.tv_sec * 1000 * 1000 + tv.tv_usec;
     
     // limit to 1.f
-    float value_orig = std::max(std::min(vu->value, 1.f), 0.f);
+    float value_orig = MAX(MIN(vu->value, 1.f), 0.f);
     float value = 0.f;
     
     // falloff?
@@ -269,14 +270,14 @@
             // blinder left -> hold LED
             int hold_x = round((vu->last_value) * (led_w + led_m)); // add last led_m removed earlier
             hold_x -= hold_x % led_s + led_m;
-            hold_x = std::max(0, hold_x);
+            hold_x = MAX(0, hold_x);
             cairo_rectangle( c, led_x, led_y, hold_x, led_h);
             
             // blinder hold LED -> value
             int val_x = round((1 - value) * (led_w + led_m)); // add last led_m removed earlier
             val_x -= val_x % led_s;
-            int blind_x = std::min(hold_x + led_s, led_w);
-            int blind_w = std::min(std::max(led_w - val_x - hold_x - led_s, 0), led_w);
+            int blind_x = MIN(hold_x + led_s, led_w);
+            int blind_w = MIN(MAX(led_w - val_x - hold_x - led_s, 0), led_w);
             cairo_rectangle(c, led_x + blind_x, led_y, blind_w, led_h);
         } else  if( vu->mode == VU_STANDARD_CENTER ) {
             if(value > vu->last_value) {
@@ -302,7 +303,7 @@
             int val_x = round(value * (led_w + led_m)); // add last led_m removed earlier
             val_x -= val_x % led_s;
             int blind_w = led_w - hold_x - led_s - val_x;
-            blind_w = std::min(std::max(blind_w, 0), led_w);
+            blind_w = MIN(MAX(blind_w, 0), led_w);
             cairo_rectangle(c, led_x + val_x, led_y, blind_w, led_h);
             cairo_rectangle( c, led_x + led_w - hold_x, led_y, hold_x, led_h);
         }
diff -Naur calf-0.0.19kx/src/giface.cpp calf-0.0.19kx.patched/src/giface.cpp
--- calf-0.0.19kx/src/giface.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/giface.cpp	2017-07-05 18:02:41.488727026 -0400
@@ -23,6 +23,7 @@
 #include <calf/giface.h>
 #include <calf/osctlnet.h>
 #include <calf/utils.h>
+#include "minmax.h"
 
 using namespace std;
 using namespace calf_utils;
@@ -49,7 +50,7 @@
         if (value01 < 0.00001)
             value = min;
         else {
-            float rmin = std::max(1.0f / 1024.0f, min);
+            float rmin = MAX(1.0f / 1024.0f, min);
             value = rmin * pow(double(max / rmin), value01);
         }
         break;
@@ -99,7 +100,7 @@
     case PF_SCALE_GAIN:
         if (value < 1.0 / 1024.0) // new bottom limit - 60 dB
             return 0;
-        double rmin = std::max(1.0f / 1024.0f, min);
+        double rmin = MAX(1.0f / 1024.0f, min);
         value /= rmin;
         return log((double)value) / log(max / rmin);
     }
@@ -129,10 +130,10 @@
         sprintf(buf, "%0.0f dB", 6.0 * log(min) / log(2));
         len = strlen(buf);
         sprintf(buf, "%0.0f dB", 6.0 * log(max) / log(2));
-        len = std::max(len, strlen(buf)) + 2;
+        len = MAX(len, strlen(buf)) + 2;
         return (int)len;
     }
-    return std::max(to_string(min).length(), std::max(to_string(max).length(), to_string(min + (max-min) * 0.987654).length()));
+    return MAX(to_string(min).length(), MAX(to_string(max).length(), to_string(min + (max-min) * 0.987654).length()));
 }
 
 std::string parameter_properties::to_string(float value) const
diff -Naur calf-0.0.19kx/src/makerdf.cpp calf-0.0.19kx.patched/src/makerdf.cpp
--- calf-0.0.19kx/src/makerdf.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/makerdf.cpp	2017-07-05 18:11:24.534699209 -0400
@@ -21,6 +21,7 @@
 #include <calf/giface.h>
 #include <calf/preset.h>
 #include <calf/utils.h>
+#include "minmax.h"
 #if USE_LV2
 #include <calf/lv2.h>
 #include <calf/lv2_event.h>
@@ -538,7 +539,7 @@
             "    lv2:port \n"
         ;
         
-        unsigned int count = min(pr.param_names.size(), pr.values.size());
+        unsigned int count = MIN(pr.param_names.size(), pr.values.size());
         for (unsigned int j = 0; j < count; j++)
         {
             presets_ttl += "        [ lv2:symbol \"" + pr.param_names[j] + "\" ; lv2p:value " + ff2s(pr.values[j]) + " ] ";
diff -Naur calf-0.0.19kx/src/minmax.h calf-0.0.19kx.patched/src/minmax.h
--- calf-0.0.19kx/src/minmax.h	1969-12-31 19:00:00.000000000 -0500
+++ calf-0.0.19kx.patched/src/minmax.h	2017-07-05 18:17:34.976679508 -0400
@@ -0,0 +1,8 @@
+/* this stuff was copy/pasted from /usr/include/sys/param.h on Slack 14.2 */
+#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define MAX(a,b) (((a)>(b))?(a):(b))
+#endif
diff -Naur calf-0.0.19kx/src/modules.cpp calf-0.0.19kx.patched/src/modules.cpp
--- calf-0.0.19kx/src/modules.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/modules.cpp	2017-07-05 18:06:28.366714960 -0400
@@ -26,6 +26,7 @@
 #include <calf/modules.h>
 #include <calf/modules_dev.h>
 #include <sys/time.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -68,7 +69,7 @@
 uint32_t reverb_audio_module::process(uint32_t offset, uint32_t numsamples, uint32_t inputs_mask, uint32_t outputs_mask)
 {
     numsamples += offset;
-    clip   -= std::min(clip, numsamples);
+    clip   -= MIN(clip, numsamples);
     for (uint32_t i = offset; i < numsamples; i++) {
         float dry = dryamount.get();
         float wet = amount.get();
@@ -81,8 +82,8 @@
         reverb.process(rl, rr);
         outs[0][i] = dry*s.left + wet*rl;
         outs[1][i] = dry*s.right + wet*rr;
-        meter_wet = std::max(fabs(wet*rl), fabs(wet*rr));
-        meter_out = std::max(fabs(outs[0][i]), fabs(outs[1][i]));
+        meter_wet = MAX(fabs(wet*rl), fabs(wet*rr));
+        meter_out = MAX(fabs(outs[0][i]), fabs(outs[1][i]));
         if(outs[0][i] > 1.f or outs[1][i] > 1.f) {
             clip = srate >> 3;
         }
@@ -573,10 +574,10 @@
             meter_outR = 0.f;
         } else {
             // let meters fall a bit
-            clip_inL    -= std::min(clip_inL,  numsamples);
-            clip_inR    -= std::min(clip_inR,  numsamples);
-            clip_outL   -= std::min(clip_outL, numsamples);
-            clip_outR   -= std::min(clip_outR, numsamples);
+            clip_inL    -= MIN(clip_inL,  numsamples);
+            clip_inR    -= MIN(clip_inR,  numsamples);
+            clip_outL   -= MIN(clip_outL, numsamples);
+            clip_outR   -= MIN(clip_outR, numsamples);
             meter_inL = 0.f;
             meter_inR = 0.f;
             meter_outL = 0.f;
@@ -590,8 +591,8 @@
             R *= *params[param_level_in];
             
             // balance in
-            L *= (1.f - std::max(0.f, *params[param_balance_in]));
-            R *= (1.f + std::min(0.f, *params[param_balance_in]));
+            L *= (1.f - MAX(0.f, *params[param_balance_in]));
+            R *= (1.f + MIN(0.f, *params[param_balance_in]));
             
             // copy / flip / mono ...
             switch((int)*params[param_mode])
@@ -688,8 +689,8 @@
             pos = (pos + 2) % buffer_size;
             
             // balance out
-            L *= (1.f - std::max(0.f, *params[param_balance_out]));
-            R *= (1.f + std::min(0.f, *params[param_balance_out]));
+            L *= (1.f - MAX(0.f, *params[param_balance_out]));
+            R *= (1.f + MIN(0.f, *params[param_balance_out]));
             
             // level 
             L *= *params[param_level_out];
@@ -782,9 +783,9 @@
             meter_outR  = 0.f;
         } else {
             // let meters fall a bit
-            clip_in     -= std::min(clip_in,  numsamples);
-            clip_outL   -= std::min(clip_outL, numsamples);
-            clip_outR   -= std::min(clip_outR, numsamples);
+            clip_in     -= MIN(clip_in,  numsamples);
+            clip_outL   -= MIN(clip_outL, numsamples);
+            clip_outR   -= MIN(clip_outR, numsamples);
             meter_in     = 0.f;
             meter_outL   = 0.f;
             meter_outR   = 0.f;
@@ -847,8 +848,8 @@
             pos = (pos + 2) % buffer_size;
             
             // balance out
-            L *= (1.f - std::max(0.f, *params[param_balance_out]));
-            R *= (1.f + std::min(0.f, *params[param_balance_out]));
+            L *= (1.f - MAX(0.f, *params[param_balance_out]));
+            R *= (1.f + MIN(0.f, *params[param_balance_out]));
             
             // level 
             L *= *params[param_level_out];
@@ -1027,8 +1028,8 @@
 uint32_t analyzer_audio_module::process(uint32_t offset, uint32_t numsamples, uint32_t inputs_mask, uint32_t outputs_mask) {
     for(uint32_t i = offset; i < offset + numsamples; i++) {
         // let meters fall a bit
-        clip_L   -= std::min(clip_L, numsamples);
-        clip_R   -= std::min(clip_R, numsamples);
+        clip_L   -= MIN(clip_L, numsamples);
+        clip_R   -= MIN(clip_R, numsamples);
         meter_L   = 0.f;
         meter_R   = 0.f;
         
@@ -1043,7 +1044,7 @@
         phase_buffer[ppos] = L * *params[param_gonio_level];
         phase_buffer[ppos + 1] = R * *params[param_gonio_level];
         
-        plength = std::min(phase_buffer_size, plength + 2);
+        plength = MIN(phase_buffer_size, plength + 2);
         ppos += 2;
         ppos %= (phase_buffer_size - 2);
         
@@ -1075,7 +1076,7 @@
     srate = sr;
     phase_buffer_size = srate / 30 * 2;
     phase_buffer_size -= phase_buffer_size % 2;
-    phase_buffer_size = std::min(phase_buffer_size, (int)max_phase_buffer_size);
+    phase_buffer_size = MIN(phase_buffer_size, (int)max_phase_buffer_size);
 }
 
 bool analyzer_audio_module::get_phase_graph(float ** _buffer, int *_length, int * _mode, bool * _use_fade, float * _fade, int * _accuracy, bool * _display) const {
@@ -1348,12 +1349,12 @@
         if(*params[param_analyzer_scale] or *params[param_analyzer_view] == 2) {
             // we have linear view enabled or we want to see tit... erm curves
             if((i % lintrans == 0 and points - i > lintrans) or i == points - 1) {
-                _iter = std::max(1, (int)floor(freq * \
+                _iter = MAX(1, (int)floor(freq * \
                     (float)_accuracy / (float)srate));
             }    
         } else {
             // we have logarithmic view enabled
-            _iter = std::max(1, (int)floor(freq * (float)_accuracy / (float)srate));
+            _iter = MAX(1, (int)floor(freq * (float)_accuracy / (float)srate));
         }
         if(_iter > iter) {
             // we are flipping one step further in drawing
@@ -1399,7 +1400,7 @@
                                 break;
                             case 3:
                                 // Analyzer Denoised Peaks - filter out unwanted noise
-                                for(int k = 0; k < std::max(10 , std::min(400 ,\
+                                for(int k = 0; k < MAX(10 , MIN(400 ,\
                                     (int)(2.f*(float)((_iter - iter))))); k++) {
                                     //collect amplitudes in the environment of _iter to
                                     //be able to erase them from signal and leave just
@@ -1426,12 +1427,12 @@
                                 lastoutL = fft_outL[_iter];
                                 //pumping up actual signal an erase surrounding
                                 // sounds
-                                fft_outL[_iter] = 0.25f * std::max(n * 0.6f * \
+                                fft_outL[_iter] = 0.25f * MAX(n * 0.6f * \
                                     fabs(fft_outL[_iter]) - var1L , 1e-20);
                                 if(_param_mode == 3 or _param_mode == 4) {
                                     // do the same with R channel if needed
                                     lastoutR = fft_outR[_iter];
-                                    fft_outR[_iter] = 0.25f * std::max(n * \
+                                    fft_outR[_iter] = 0.25f * MAX(n * \
                                         0.6f * fabs(fft_outR[_iter]) - var1R , 1e-20);
                                 }
                                 break;
diff -Naur calf-0.0.19kx/src/modules_comp.cpp calf-0.0.19kx.patched/src/modules_comp.cpp
--- calf-0.0.19kx/src/modules_comp.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/modules_comp.cpp	2017-07-05 18:11:10.031699980 -0400
@@ -22,6 +22,7 @@
 #include <memory.h>
 #include <calf/giface.h>
 #include <calf/modules_comp.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -201,10 +202,10 @@
         // process all strips
 
         // let meters fall a bit
-        clip_inL    -= std::min(clip_inL,  numsamples);
-        clip_inR    -= std::min(clip_inR,  numsamples);
-        clip_outL   -= std::min(clip_outL, numsamples);
-        clip_outR   -= std::min(clip_outR, numsamples);
+        clip_inL    -= MIN(clip_inL,  numsamples);
+        clip_inR    -= MIN(clip_inR,  numsamples);
+        clip_outL   -= MIN(clip_outL, numsamples);
+        clip_outR   -= MIN(clip_outR, numsamples);
         meter_inL = 0.f;
         meter_inR = 0.f;
         meter_outL = 0.f;
@@ -1025,8 +1026,8 @@
     } else {
         // process
 
-        detected_led -= std::min(detected_led,  numsamples);
-        clip_led   -= std::min(clip_led,  numsamples);
+        detected_led -= MIN(detected_led,  numsamples);
+        clip_led   -= MIN(clip_led,  numsamples);
         compressor.update_curve();
 
         while(offset < numsamples) {
@@ -1081,18 +1082,18 @@
             outs[0][offset] = outL;
             outs[1][offset] = outR;
 
-            if(std::max(fabs(leftSC), fabs(rightSC)) > *params[param_threshold]) {
+            if(MAX(fabs(leftSC), fabs(rightSC)) > *params[param_threshold]) {
                 detected_led   = srate >> 3;
             }
-            if(std::max(fabs(leftAC), fabs(rightAC)) > 1.f) {
+            if(MAX(fabs(leftAC), fabs(rightAC)) > 1.f) {
                 clip_led   = srate >> 3;
             }
             if(clip_led > 0) {
                 clip_out = 1.f;
             } else {
-                clip_out = std::max(fabs(outL), fabs(outR));
+                clip_out = MAX(fabs(outL), fabs(outR));
             }
-            detected = std::max(fabs(leftMC), fabs(rightMC));
+            detected = MAX(fabs(leftMC), fabs(rightMC));
 
             // next sample
             ++offset;
@@ -1896,10 +1897,10 @@
         // process all strips
 
         // let meters fall a bit
-        clip_inL    -= std::min(clip_inL,  numsamples);
-        clip_inR    -= std::min(clip_inR,  numsamples);
-        clip_outL   -= std::min(clip_outL, numsamples);
-        clip_outR   -= std::min(clip_outR, numsamples);
+        clip_inL    -= MIN(clip_inL,  numsamples);
+        clip_inR    -= MIN(clip_inR,  numsamples);
+        clip_outL   -= MIN(clip_outL, numsamples);
+        clip_outR   -= MIN(clip_outR, numsamples);
         meter_inL = 0.f;
         meter_inR = 0.f;
         meter_outL = 0.f;
@@ -2161,10 +2162,10 @@
         // greatest sounding compressor I've heard!
         bool rms = (detection == 0);
         bool average = (stereo_link == 0);
-        float attack_coeff = std::min(1.f, 1.f / (attack * srate / 4000.f));
-        float release_coeff = std::min(1.f, 1.f / (release * srate / 4000.f));
+        float attack_coeff = MIN(1.f, 1.f / (attack * srate / 4000.f));
+        float release_coeff = MIN(1.f, 1.f / (release * srate / 4000.f));
 
-        float absample = average ? (fabs(*det_left) + fabs(*det_right)) * 0.5f : std::max(fabs(*det_left), fabs(*det_right));
+        float absample = average ? (fabs(*det_left) + fabs(*det_right)) * 0.5f : MAX(fabs(*det_left), fabs(*det_right));
         if(rms) absample *= absample;
 
         dsp::sanitize(linSlope);
@@ -2177,7 +2178,7 @@
 
         left *= gain * makeup;
         right *= gain * makeup;
-        meter_out = std::max(fabs(left), fabs(right));;
+        meter_out = MAX(fabs(left), fabs(right));;
         meter_comp = gain;
         detected = rms ? sqrt(linSlope) : linSlope;
     }
@@ -2390,8 +2391,8 @@
     float linThreshold = threshold;
     if (rms)
         linThreshold = linThreshold * linThreshold;
-    attack_coeff = std::min(1.f, 1.f / (attack * srate / 4000.f));
-    release_coeff = std::min(1.f, 1.f / (release * srate / 4000.f));
+    attack_coeff = MIN(1.f, 1.f / (attack * srate / 4000.f));
+    release_coeff = MIN(1.f, 1.f / (release * srate / 4000.f));
     float linKneeSqrt = sqrt(knee);
     linKneeStart = linThreshold / linKneeSqrt;
     adjKneeStart = linKneeStart*linKneeStart;
@@ -2414,7 +2415,7 @@
         // this routine is mainly copied from Damien's expander module based on Thor's compressor
         bool rms = (detection == 0);
         bool average = (stereo_link == 0);
-        float absample = average ? (fabs(*det_left) + fabs(*det_right)) * 0.5f : std::max(fabs(*det_left), fabs(*det_right));
+        float absample = average ? (fabs(*det_left) + fabs(*det_right)) * 0.5f : MAX(fabs(*det_left), fabs(*det_right));
         if(rms) absample *= absample;
 
         dsp::sanitize(linSlope);
@@ -2426,7 +2427,7 @@
         }
         left *= gain * makeup;
         right *= gain * makeup;
-        meter_out = std::max(fabs(left), fabs(right));
+        meter_out = MAX(fabs(left), fabs(right));
         meter_gate = gain;
         detected = linSlope;
     }
@@ -2453,7 +2454,7 @@
         if(knee > 1.f && slope > kneeStart ) {
             gain = dsp::hermite_interpolation(slope, kneeStart, kneeStop, ((kneeStart - thres) * tratio  + thres), kneeStop, delta,1.f);
         }
-        return std::max(range, expf(gain-slope));
+        return MAX(range, expf(gain-slope));
     }
     return 1.f;
 }
diff -Naur calf-0.0.19kx/src/modules_dist.cpp calf-0.0.19kx.patched/src/modules_dist.cpp
--- calf-0.0.19kx/src/modules_dist.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/modules_dist.cpp	2017-07-05 18:08:59.690706912 -0400
@@ -22,6 +22,7 @@
 #include <memory.h>
 #include <calf/giface.h>
 #include <calf/modules_dist.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -223,7 +224,7 @@
         } // cycle trough samples
         meters.process(params, ins, outs, orig_offset, orig_numsamples);
         
-        tube_avg = (sqrt(std::max(out_avg[0], out_avg[1])) / numsamples) - (sqrt(std::max(in_avg[0], in_avg[1])) / numsamples);
+        tube_avg = (sqrt(MAX(out_avg[0], out_avg[1])) / numsamples) - (sqrt(MAX(in_avg[0], in_avg[1])) / numsamples);
         meter_drive = (5.0f * fabs(tube_avg) * (float(*params[param_blend]) + 30.0f));
         // printf("out:%.6f in: %.6f avg: %.6f drv: %.3f\n", sqrt(std::max(out_avg[0], out_avg[1])) / numsamples, sqrt(std::max(in_avg[0], in_avg[1])) / numsamples, tube_avg, meter_drive);
         // clean up
@@ -397,7 +398,7 @@
             maxDrive = dist[0].get_distortion_level() * *params[param_amount];
             
             if(in_count > 1 && out_count > 1) {
-                maxDrive = std::max(maxDrive, dist[1].get_distortion_level() * *params[param_amount]);
+                maxDrive = MAX(maxDrive, dist[1].get_distortion_level() * *params[param_amount]);
                 // full stereo
                 out[0] = (proc[0] * *params[param_amount] + in2out * in[0]) * *params[param_level_out];
                 out[1] = (proc[1] * *params[param_amount] + in2out * in[1]) * *params[param_level_out];
@@ -593,7 +594,7 @@
                 else
                     out[1] = (proc[1] * *params[param_amount] + in[1]) * *params[param_level_out];
                 outs[1][offset] = out[1];
-                maxDrive = std::max(dist[0].get_distortion_level() * *params[param_amount],
+                maxDrive = MAX(dist[0].get_distortion_level() * *params[param_amount],
                                             dist[1].get_distortion_level() * *params[param_amount]);
             } else if(out_count > 1) {
                 // mono -> pseudo stereo
diff -Naur calf-0.0.19kx/src/modules_limit.cpp calf-0.0.19kx.patched/src/modules_limit.cpp
--- calf-0.0.19kx/src/modules_limit.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/modules_limit.cpp	2017-07-05 18:12:57.826694247 -0400
@@ -22,6 +22,7 @@
 #include <memory.h>
 #include <calf/giface.h>
 #include <calf/modules_limit.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -110,15 +111,15 @@
         asc_led    = 0.f;
     } else {
         // let meters fall a bit
-        clip_inL    -= std::min(clip_inL,  numsamples);
-        clip_inR    -= std::min(clip_inR,  numsamples);
-        clip_outL   -= std::min(clip_outL, numsamples);
-        clip_outR   -= std::min(clip_outR, numsamples);
+        clip_inL    -= MIN(clip_inL,  numsamples);
+        clip_inR    -= MIN(clip_inR,  numsamples);
+        clip_outL   -= MIN(clip_outL, numsamples);
+        clip_outR   -= MIN(clip_outR, numsamples);
         meter_inL = 0.f;
         meter_inR = 0.f;
         meter_outL = 0.f;
         meter_outR = 0.f;
-        asc_led   -= std::min(asc_led, numsamples);
+        asc_led   -= MIN(asc_led, numsamples);
 
         while(offset < numsamples) {
             // cycle through samples
@@ -139,10 +140,10 @@
 
             // should never be used. but hackers are paranoid by default.
             // so we make shure NOTHING is above limit
-            outL = std::max(outL, -*params[param_limit]);
-            outL = std::min(outL, *params[param_limit]);
-            outR = std::max(outR, -*params[param_limit]);
-            outR = std::min(outR, *params[param_limit]);
+            outL = MAX(outL, -*params[param_limit]);
+            outL = MIN(outL, *params[param_limit]);
+            outR = MAX(outR, -*params[param_limit]);
+            outR = MIN(outR, *params[param_limit]);
 
             // autolevel
             outL /= *params[param_limit];
@@ -363,22 +364,22 @@
     float rel;
 
     rel = *params[param_release] *  pow(0.25, *params[param_release0] * -1);
-    rel = (*params[param_minrel] > 0.5) ? std::max(2500 * (1.f / 30), rel) : rel;
+    rel = (*params[param_minrel] > 0.5) ? MAX(2500 * (1.f / 30), rel) : rel;
     weight[0] = pow(0.25, *params[param_weight0] * -1);
     strip[0].set_params(*params[param_limit], *params[param_attack], rel, weight[0], *params[param_asc], pow(0.5, (*params[param_asc_coeff] - 0.5) * 2 * -1));
     *params[param_effrelease0] = rel;
     rel = *params[param_release] *  pow(0.25, *params[param_release1] * -1);
-    rel = (*params[param_minrel] > 0.5) ? std::max(2500 * (1.f / *params[param_freq0]), rel) : rel;
+    rel = (*params[param_minrel] > 0.5) ? MAX(2500 * (1.f / *params[param_freq0]), rel) : rel;
     weight[1] = pow(0.25, *params[param_weight1] * -1);
     strip[1].set_params(*params[param_limit], *params[param_attack], rel, weight[1], *params[param_asc], pow(0.5, (*params[param_asc_coeff] - 0.5) * 2 * -1), true);
     *params[param_effrelease1] = rel;
     rel = *params[param_release] *  pow(0.25, *params[param_release2] * -1);
-    rel = (*params[param_minrel] > 0.5) ? std::max(2500 * (1.f / *params[param_freq1]), rel) : rel;
+    rel = (*params[param_minrel] > 0.5) ? MAX(2500 * (1.f / *params[param_freq1]), rel) : rel;
     weight[2] = pow(0.25, *params[param_weight2] * -1);
     strip[2].set_params(*params[param_limit], *params[param_attack], rel, weight[2], *params[param_asc], pow(0.5, (*params[param_asc_coeff] - 0.5) * 2 * -1));
     *params[param_effrelease2] = rel;
     rel = *params[param_release] *  pow(0.25, *params[param_release3] * -1);
-    rel = (*params[param_minrel] > 0.5) ? std::max(2500 * (1.f / *params[param_freq2]), rel) : rel;
+    rel = (*params[param_minrel] > 0.5) ? MAX(2500 * (1.f / *params[param_freq2]), rel) : rel;
     weight[3] = pow(0.25, *params[param_weight3] * -1);
     strip[3].set_params(*params[param_limit], *params[param_attack], rel, weight[3], *params[param_asc], pow(0.5, (*params[param_asc_coeff] - 0.5) * 2 * -1));
     *params[param_effrelease3] = rel;
@@ -459,11 +460,11 @@
         // process all strips
 
         // let meters fall a bit
-        clip_inL    -= std::min(clip_inL,  numsamples);
-        clip_inR    -= std::min(clip_inR,  numsamples);
-        clip_outL   -= std::min(clip_outL, numsamples);
-        clip_outR   -= std::min(clip_outR, numsamples);
-        asc_led     -= std::min(asc_led, numsamples);
+        clip_inL    -= MIN(clip_inL,  numsamples);
+        clip_inR    -= MIN(clip_inR,  numsamples);
+        clip_outL   -= MIN(clip_outL, numsamples);
+        clip_outR   -= MIN(clip_outR, numsamples);
+        asc_led     -= MIN(asc_led, numsamples);
         meter_inL = 0.f;
         meter_inR = 0.f;
         meter_outL = 0.f;
@@ -544,7 +545,7 @@
             } // process single strip with filter
 
             // write multiband coefficient to buffer
-            buffer[pos] = std::min(*params[param_limit] / std::max(fabs(sum_left), fabs(sum_right)), 1.0);
+            buffer[pos] = MIN(*params[param_limit] / MAX(fabs(sum_left), fabs(sum_right)), 1.0);
 
             for (int i = 0; i < strips; i++) {
                 // process gain reduction
@@ -562,10 +563,10 @@
 
             // should never be used. but hackers are paranoid by default.
             // so we make shure NOTHING is above limit
-            outL = std::max(outL, -*params[param_limit]);
-            outL = std::min(outL, *params[param_limit]);
-            outR = std::max(outR, -*params[param_limit]);
-            outR = std::min(outR, *params[param_limit]);
+            outL = MAX(outL, -*params[param_limit]);
+            outL = MIN(outL, *params[param_limit]);
+            outR = MAX(outR, -*params[param_limit]);
+            outR = MIN(outR, *params[param_limit]);
 
             batt = broadband.get_attenuation();
 
diff -Naur calf-0.0.19kx/src/modules_mod.cpp calf-0.0.19kx.patched/src/modules_mod.cpp
--- calf-0.0.19kx/src/modules_mod.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/modules_mod.cpp	2017-07-05 17:59:43.420736496 -0400
@@ -22,6 +22,7 @@
 #include <memory.h>
 #include <calf/giface.h>
 #include <calf/modules_mod.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -308,12 +309,12 @@
 inline bool rotary_speaker_audio_module::incr_towards(float &aspeed, float raspeed, float delta_decc, float delta_acc)
 {
     if (aspeed < raspeed) {
-        aspeed = std::min(raspeed, aspeed + delta_acc);
+        aspeed = MIN(raspeed, aspeed + delta_acc);
         return true;
     }
     else if (aspeed > raspeed) 
     {
-        aspeed = std::max(raspeed, aspeed - delta_decc);
+        aspeed = MAX(raspeed, aspeed - delta_decc);
         return true;
     }        
     return false;
@@ -520,7 +521,7 @@
     left.lfo.set_voices(voices); right.lfo.set_voices(voices);
     left.lfo.set_overlap(overlap);right.lfo.set_overlap(overlap);
     float vphase = *params[par_vphase] * (1.f / 360.f);
-    left.lfo.vphase = right.lfo.vphase = vphase * (4096 / std::max(voices - 1, 1));
+    left.lfo.vphase = right.lfo.vphase = vphase * (4096 / MAX(voices - 1, 1));
     float r_phase = *params[par_stereo] * (1.f / 360.f);
     if (fabs(r_phase - last_r_phase) > 0.0001f) {
         right.lfo.phase = left.lfo.phase;
@@ -619,10 +620,10 @@
         
     } else {
         
-        clip_inL    -= std::min(clip_inL,  numsamples);
-        clip_inR    -= std::min(clip_inR,  numsamples);
-        clip_outL   -= std::min(clip_outL, numsamples);
-        clip_outR   -= std::min(clip_outR, numsamples);
+        clip_inL    -= MIN(clip_inL,  numsamples);
+        clip_inR    -= MIN(clip_inR,  numsamples);
+        clip_outL   -= MIN(clip_outL, numsamples);
+        clip_outR   -= MIN(clip_outR, numsamples);
         meter_inL = 0.f;
         meter_inR = 0.f;
         meter_outL = 0.f;
diff -Naur calf-0.0.19kx/src/monosynth.cpp calf-0.0.19kx.patched/src/monosynth.cpp
--- calf-0.0.19kx/src/monosynth.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/monosynth.cpp	2017-07-05 18:03:42.319723791 -0400
@@ -20,6 +20,7 @@
  */
 #include <calf/giface.h>
 #include <calf/modules_synths.h>
+#include "minmax.h"
 
 using namespace dsp;
 using namespace calf_plugins;
@@ -115,11 +116,11 @@
     waves[wave_varistep].make(bl, data);
 
     for (int i = 0; i < S; i++) {
-        data[i] = (min(1.f, (float)(i / 64.f))) * (1.0 - i * 1.0 / S) * (-1 + fmod (i * i * 8/ (S * S * 1.0), 2.0));
+        data[i] = (MIN(1.f, (float)(i / 64.f))) * (1.0 - i * 1.0 / S) * (-1 + fmod (i * i * 8/ (S * S * 1.0), 2.0));
     }
     waves[wave_skewsaw].make(bl, data);
     for (int i = 0; i < S; i++) {
-        data[i] = (min(1.f, (float)(i / 64.f))) * (1.0 - i * 1.0 / S) * (fmod (i * i * 8/ (S * S * 1.0), 2.0) < 1.0 ? -1.0 : +1.0);
+        data[i] = (MIN(1.f, (float)(i / 64.f))) * (1.0 - i * 1.0 / S) * (fmod (i * i * 8/ (S * S * 1.0), 2.0) < 1.0 ? -1.0 : +1.0);
     }
     waves[wave_skewsqr].make(bl, data);
 
@@ -441,7 +442,7 @@
     if (*params[param] <= 0)
         return lfo.get();
     float pt = lfo_clock / *params[param];
-    return lfo.get() * std::min(1.0f, pt);
+    return lfo.get() * MIN(1.0f, pt);
 }
 
 void monosynth_audio_module::calculate_step()
@@ -518,32 +519,32 @@
     case flt_lp12:
         filter.set_lp_rbj(cutoff, resonance, srate);
         filter2.set_null();
-        newfgain = min(0.7f, 0.7f / resonance) * ampctl;
+        newfgain = MIN(0.7f, 0.7f / resonance) * ampctl;
         break;
     case flt_hp12:
         filter.set_hp_rbj(cutoff, resonance, srate);
         filter2.set_null();
-        newfgain = min(0.7f, 0.7f / resonance) * ampctl;
+        newfgain = MIN(0.7f, 0.7f / resonance) * ampctl;
         break;
     case flt_lp24:
         filter.set_lp_rbj(cutoff, resonance, srate);
         filter2.set_lp_rbj(cutoff2, resonance, srate);
-        newfgain = min(0.5f, 0.5f / resonance) * ampctl;
+        newfgain = MIN(0.5f, 0.5f / resonance) * ampctl;
         break;
     case flt_lpbr:
         filter.set_lp_rbj(cutoff, resonance, srate);
         filter2.set_br_rbj(cutoff2, 1.0 / resonance, srate);
-        newfgain = min(0.5f, 0.5f / resonance) * ampctl;        
+        newfgain = MIN(0.5f, 0.5f / resonance) * ampctl;        
         break;
     case flt_hpbr:
         filter.set_hp_rbj(cutoff, resonance, srate);
         filter2.set_br_rbj(cutoff2, 1.0 / resonance, srate);
-        newfgain = min(0.5f, 0.5f / resonance) * ampctl;        
+        newfgain = MIN(0.5f, 0.5f / resonance) * ampctl;        
         break;
     case flt_2lp12:
         filter.set_lp_rbj(cutoff, resonance, srate);
         filter2.set_lp_rbj(cutoff2, resonance, srate);
-        newfgain = min(0.7f, 0.7f / resonance) * ampctl;
+        newfgain = MIN(0.7f, 0.7f / resonance) * ampctl;
         break;
     case flt_bp6:
         filter.set_bp_rbj(cutoff, resonance, srate);
@@ -728,8 +729,8 @@
 void monosynth_audio_module::params_changed()
 {
     float sf = 0.001f;
-    envelope1.set(*params[par_env1attack] * sf, *params[par_env1decay] * sf, std::min(0.999f, *params[par_env1sustain]), *params[par_env1release] * sf, srate / step_size, *params[par_env1fade] * sf);
-    envelope2.set(*params[par_env2attack] * sf, *params[par_env2decay] * sf, std::min(0.999f, *params[par_env2sustain]), *params[par_env2release] * sf, srate / step_size, *params[par_env2fade] * sf);
+    envelope1.set(*params[par_env1attack] * sf, *params[par_env1decay] * sf, MIN(0.999f, *params[par_env1sustain]), *params[par_env1release] * sf, srate / step_size, *params[par_env1fade] * sf);
+    envelope2.set(*params[par_env2attack] * sf, *params[par_env2decay] * sf, MIN(0.999f, *params[par_env2sustain]), *params[par_env2release] * sf, srate / step_size, *params[par_env2fade] * sf);
     filter_type = dsp::fastf2i_drm(*params[par_filtertype]);
     separation = pow(2.0, *params[par_cutoffsep] / 1200.0);
     wave1 = dsp::clip(dsp::fastf2i_drm(*params[par_wave1]), 0, (int)wave_count - 1);
@@ -756,7 +757,7 @@
             calculate_step();
         if(op < op_end) {
             uint32_t ip = output_pos;
-            uint32_t len = std::min(step_size - output_pos, op_end - op);
+            uint32_t len = MIN(step_size - output_pos, op_end - op);
             if (running)
             {
                 had_data = 3;
diff -Naur calf-0.0.19kx/src/organ.cpp calf-0.0.19kx.patched/src/organ.cpp
--- calf-0.0.19kx/src/organ.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/organ.cpp	2017-07-05 18:07:06.994712906 -0400
@@ -23,6 +23,7 @@
 #include <calf/giface.h>
 #include <calf/organ.h>
 #include <iostream>
+#include "minmax.h"
 
 using namespace std;
 using namespace dsp;
@@ -1079,7 +1080,7 @@
     if (dsp::fastf2i_drm(parameters->lfo_mode) == organ_voice_base::lfomode_global)
     {
         for (int i = 0; i < nsamples; i += 64)
-            global_vibrato.process(parameters, buf + i, std::min(64, nsamples - i), sample_rate);
+            global_vibrato.process(parameters, buf + i, MIN(64, nsamples - i), sample_rate);
     }
     if (percussion.get_active())
         percussion.render_percussion_to(buf, nsamples);
diff -Naur calf-0.0.19kx/src/plugin_gui_window.cpp calf-0.0.19kx.patched/src/plugin_gui_window.cpp
--- calf-0.0.19kx/src/plugin_gui_window.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/plugin_gui_window.cpp	2017-07-05 18:03:59.454722879 -0400
@@ -25,6 +25,7 @@
 #include <gdk/gdk.h>
 
 #include <iostream>
+#include "minmax.h"
 
 using namespace calf_plugins;
 using namespace std;
@@ -367,7 +368,7 @@
     gui->show_rack_ears(environment->get_config()->rack_ears);
     
     gtk_widget_size_request(GTK_WIDGET(container), &req);
-    int wx = max(req.width + 10, req2.width);
+    int wx = MAX(req.width + 10, req2.width);
     int wy = req.height + req2.height + 10;
     // printf("size request %dx%d\n", req.width, req.height);
     // printf("resize to %dx%d\n", max(req.width + 10, req2.width), req.height + req2.height + 10);
diff -Naur calf-0.0.19kx/src/preset.cpp calf-0.0.19kx.patched/src/preset.cpp
--- calf-0.0.19kx/src/preset.cpp	2014-03-08 16:26:41.000000000 -0500
+++ calf-0.0.19kx.patched/src/preset.cpp	2017-07-05 18:09:33.377705120 -0400
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sys/stat.h>
+#include "minmax.h"
 
 using namespace std;
 using namespace calf_plugins;
@@ -86,7 +87,7 @@
     for (int i = 0; i < count; i++)
         names[metadata->get_param_props(i)->short_name] = i;
     // no support for unnamed parameters... tough luck :)
-    for (unsigned int i = 0; i < min(param_names.size(), values.size()); i++)
+    for (unsigned int i = 0; i < MIN(param_names.size(), values.size()); i++)
     {
         map<string, int>::iterator pos = names.find(param_names[i]);
         if (pos == names.end()) {
